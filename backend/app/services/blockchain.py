from app.core.config import settings
from web3 import Web3
import hashlib
import json
import os
from datetime import datetime

class BlockchainService:
    def __init__(self):
        # Default to local hardhat if not set in settings
        self.rpc_url = settings.BLOCKCHAIN_RPC_URL or "http://127.0.0.1:8545"
        self.w3 = Web3(Web3.HTTPProvider(self.rpc_url))
        self.contract = None
        self.contract_address = None
        
        # Load Contract Config (generated by deploy.js)
        # We look for blockchain_config.json in the app root or relative path
        config_path = os.path.join(os.path.dirname(__file__), "blockchain_config.json") # Updated path to be in app/services/ or similar? 
        # Actually my deploy script puts it in backend/app/blockchain_config.json
        # So from app/services/blockchain.py (which is __file__), we go up one level to app/blockchain_config.json
        config_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "../blockchain_config.json"))

        if os.path.exists(config_path):
            try:
                with open(config_path, "r") as f:
                    config = json.load(f)
                    self.contract_address = config.get("address")
                    abi = config.get("abi")
                    
                    if self.contract_address and abi and self.w3.is_connected():
                        # Determine Chain ID to ensure we are on the right network (Localhost: 1337)
                        # self.w3.eth.chain_id 
                        self.contract = self.w3.eth.contract(address=self.contract_address, abi=abi)
                        print(f"Blockchain Connected: {self.contract_address}")
            except Exception as e:
                print(f"Failed to load blockchain config: {e}")
        else:
            print(f"Blockchain config not found at {config_path}. Run 'npx hardhat run scripts/deploy.js --network localhost' in blockchain/ folder.")

        # Fallback to local file-based ledger ONLY if blockchain is not active
        self.ledger_file = "local_blockchain_ledger.json"
        
        # Test Account for MVP (In prod, use env var or KMS)
        # Hardhat Account #0
        self.private_key = os.getenv("BLOCKCHAIN_PRIVATE_KEY", "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80")
        self.account_address = "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"

    def calculate_hash(self, file_content: bytes) -> str:
        return hashlib.sha256(file_content).hexdigest()

    def store_hash_on_chain(
        self, 
        case_id: str, 
        evidence_id: str, 
        file_hash: str, 
        file_type: str, 
        uploader_role: str, 
        previous_hash: str = None
    ):
        """
        Stores the hash and metadata on the blockchain.
        Returns the transaction hash.
        """
        previous_hash = previous_hash or ""
        
        if self.w3.is_connected() and self.contract:
            try:
                # Build Transaction
                nonce = self.w3.eth.get_transaction_count(self.account_address)
                
                # anchorEvidence(evidenceId, fileHash, fileType, caseId, uploaderRole, previousHash)
                tx_call = self.contract.functions.anchorEvidence(
                    evidence_id, 
                    file_hash, 
                    file_type, 
                    case_id, 
                    uploader_role, 
                    previous_hash
                ).build_transaction({
                    'chainId': 1337, # Hardhat Local
                    'gas': 2000000,
                    'gasPrice': self.w3.to_wei('1', 'gwei'),
                    'nonce': nonce,
                    'from': self.account_address
                })
                
                # Sign
                signed_tx = self.w3.eth.account.sign_transaction(tx_call, private_key=self.private_key)
                
                # Send
                tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
                
                # Wait for receipt (optional, but good for immediate confirmation)
                self.w3.eth.wait_for_transaction_receipt(tx_hash)
                
                return self.w3.to_hex(tx_hash)
                
            except Exception as e:
                print(f"Blockchain Transaction Failed: {e}")
                # Fallthrough to fallback if chain fails? Or raise error?
                # For demo reliability, we fall back.
                pass
        
        # Fallback to local ledger
        print("Using Local Ledger Fallback")
        entry = {
            "case_id": case_id,
            "evidence_id": evidence_id,
            "hash": file_hash,
            "file_type": file_type,
            "uploader_role": uploader_role,
            "previous_hash": previous_hash,
            "timestamp": str(datetime.now())
        }
        self._append_to_ledger(entry)
        return f"0xLOCAL_LEDGER_{hashlib.md5(file_hash.encode()).hexdigest()}"

    def verify_integrity(self, evidence_id: str, computed_hash: str) -> dict:
        """
        Verifies if the computed hash matches the stored hash on chain.
        """
        # Try Blockchain First
        if self.w3.is_connected() and self.contract:
            try:
                # Call contract view function
                # Returns (evidenceId, fileHash, fileType, caseId, uploaderRole, timestamp, previousHash, uploaderAddress)
                # But we defined a struct, so it returns a tuple of the struct fields
                evidence_data = self.contract.functions.getEvidence(evidence_id).call()
                
                # Check if evidence exists (evidenceId is not empty)
                if not evidence_data or not evidence_data[0]: 
                    return {
                        "verified": False,
                        "status": "NOT_FOUND_ON_CHAIN",
                        "details": "Evidence ID not found in the blockchain contract.",
                        "provider": "Local Hardhat Node"
                    }
                
                stored_hash = evidence_data[1]
                timestamp_unix = evidence_data[5]
                timestamp_str = datetime.fromtimestamp(timestamp_unix).strftime('%Y-%m-%d %H:%M:%S')
                
                is_valid = (stored_hash == computed_hash)
                
                return {
                    "verified": is_valid,
                    "status": "VERIFIED" if is_valid else "TAMPERED",
                    "details": "Hash matches blockchain record." if is_valid else "Hash Mismatch! File altered.",
                    "provider": "Local Hardhat Node",
                    "blockchain_record": {
                        "timestamp": timestamp_str,
                        "uploader_role": evidence_data[4],
                        "stored_hash": stored_hash,
                        "block_explorer": "Localhost"
                    }
                }
            except Exception as e:
                print(f"Blockchain Verification Error: {e}")
                # Fallback to file
        
        # Fallback
        record = self._get_record_from_ledger(evidence_id)
        
        if not record:
            return {
                "verified": False,
                "status": "NOT_FOUND_ON_CHAIN",
                "details": "Evidence ID not found in the blockchain ledger."
            }
            
        stored_hash = record.get("hash")
        is_valid = (stored_hash == computed_hash)
        
        return {
            "verified": is_valid,
            "status": "VERIFIED" if is_valid else "TAMPERED",
            "details": "Hash matches blockchain record." if is_valid else "Hash Mismatch! File may have been altered.",
            "provider": "Local File Mock",
            "blockchain_record": {
                "timestamp": record.get("timestamp"),
                "uploader_role": record.get("uploader_role"),
                "stored_hash": stored_hash
            }
        }

    def _append_to_ledger(self, entry):
        try:
            with open(self.ledger_file, 'r') as f:
                data = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            data = []
        
        data.append(entry)
        
        with open(self.ledger_file, 'w') as f:
            json.dump(data, f)
            
    def _get_hash_from_ledger(self, evidence_id):
        record = self._get_record_from_ledger(evidence_id)
        return record.get("hash") if record else None

    def _get_record_from_ledger(self, evidence_id):
        try:
            with open(self.ledger_file, 'r') as f:
                data = json.load(f)
                for entry in data:
                    if entry.get("evidence_id") == evidence_id:
                        return entry
        except FileNotFoundError:
            return None
        return None

blockchain = BlockchainService()
